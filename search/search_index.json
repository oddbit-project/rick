{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Rick Rick is a plumbing library for micro framework design. It provides base classes for miscellaneous purposes, ranging from dependency injection to validation. However, it does not include any HTTP/{A,W}SGI functionality, nor any database-related functionality; you should instead using other existing projects for that functionality, such as Flask for MVC and RickDb for database operations. Components Dependency Injection (DI) class; Container class; Generic resource map loader class; Registry class; Cache interface; REDIS cache client; AES256 crypto functions for cache mechanisms; Event manager; Form component; Validator class; Assorted validators;","title":"Overview"},{"location":"#welcome-to-rick","text":"Rick is a plumbing library for micro framework design. It provides base classes for miscellaneous purposes, ranging from dependency injection to validation. However, it does not include any HTTP/{A,W}SGI functionality, nor any database-related functionality; you should instead using other existing projects for that functionality, such as Flask for MVC and RickDb for database operations.","title":"Welcome to Rick"},{"location":"#components","text":"Dependency Injection (DI) class; Container class; Generic resource map loader class; Registry class; Cache interface; REDIS cache client; AES256 crypto functions for cache mechanisms; Event manager; Form component; Validator class; Assorted validators;","title":"Components"},{"location":"requests/","text":"Managing Requests Rick provides several distinct classes to aid the management of request data: FieldRecord, RequestRecord and Form. While these classes share a common syntax, their use cases are different. FieldRecord The FieldRecord class implements common form field handling. The fields are defined dynamically, allowing for the adding or removal of fields in runtime. It has no additional control logic available, nor provides a way of grouping fields. FieldRecord example: from rick.form import FieldRecord from rick.mixin import Translator class MyFieldRecord ( FieldRecord ): def init ( self ): self . field ( 'name' , validators = \"required|minlen:4|maxlen:8\" ) \\ . field ( 'age' , validators = \"required|numeric|between:9,125\" ) \\ . field ( 'phone' , validators = \"numeric|minlen:8|maxlen:16\" ) return self def validator_name ( self , data , t : Translator ): \"\"\" Sample custom validator for field 'name' This validator is triggered during the is_valid() call when the all the initial field validators execute successfully \"\"\" if data [ 'name' ] == 'dave' : self . add_error ( 'name' , 'Dave is not here, man' ) return False return True ( ... ) data = {} frm = MyFieldRecord () . init () if frm . is_valid ( data ): pass # do something on success else : # dump error string print ( frm . get_errors ()) Form The Form class extends FieldRecord and adds grouping of fields (fieldsets), support for control elements (buttons, etc) and basic HTTP-related properties, such as action URL and HTTP method. Form example: from rick.form import Form from rick.mixin import Translator class MyForm ( Form ): def init ( self ): self . set_action ( '/user/create' ) self . set_method ( self . METHOD_POST ) # implicitly uses the default fieldset self . field ( 'text' , 'name' , 'Full Name' , validators = \"required|minlen:4|maxlen:8\" ) \\ . field ( 'text' , 'age' , 'Age' , validators = \"required|numeric|between:9,125\" ) \\ . field ( 'text' , 'phone' , 'Phone' , validators = \"numeric|minlen:8|maxlen:16\" ) # a separate fieldset self . fieldset ( 'tab2' , 'Details' ) \\ . field ( 'text' , 'address' , 'Home Address' , validators = \"required\" ) self . control ( 'submit' , 'save' , 'Save' ) \\ . control ( 'reset' , 'clear' , 'Clear Form' ) return self def validator_name ( self , data , t : Translator ): \"\"\" Sample custom validator for field 'name' This validator is triggered during the is_valid() call when the all the initial field validators execute successfully \"\"\" if data [ 'name' ] == 'dave' : self . add_error ( 'name' , 'Dave is not here, man' ) return False return True ( ... ) data = {} frm = MyForm () . init () if frm . is_valid ( data ): pass # do something on success else : # dump error string print ( frm . get_errors ()) RequestRecord The RequestRecord class provides a way of declaring and validating simple field structures, suitable for eg. API usage. Fields are defined on class declaration, and there is no field grouping available, nor an initializer method. All the field-related options are available, including validators and filters. On success, field values can be accessed directly via the attributes, e.g. object.field.value. Please note: field names must not start with an underscore('_'); underscore attributes are considered private and internal to the class implementation. RequestRecord example: from rick.form import Field from rick.request import RequestRecord from rick.mixin import Translator class UserRequest ( RequestRecord ): name = Field ( validators = \"required|minlen:4|maxlen:8\" ) age = Field ( validators = \"required|numeric|between:9,125\" ) phone = Field ( validators = \"numeric|minlen:8|maxlen:16\" ) def validator_name ( self , data , t : Translator ): \"\"\" Sample custom validator for field 'name' This validator is triggered during the is_valid() call when the all the initial field validators execute successfully \"\"\" if data [ 'name' ] == 'dave' : self . add_error ( 'name' , 'Dave is not here, man' ) return False return True ( ... ) data = {} frm = UserRequest () if frm . is_valid ( data ): print ( \"User name is: {} \" . format ( frm . name . value )) else : # dump error string print ( frm . get_errors ())","title":"Requests & fields"},{"location":"requests/#managing-requests","text":"Rick provides several distinct classes to aid the management of request data: FieldRecord, RequestRecord and Form. While these classes share a common syntax, their use cases are different.","title":"Managing Requests"},{"location":"requests/#fieldrecord","text":"The FieldRecord class implements common form field handling. The fields are defined dynamically, allowing for the adding or removal of fields in runtime. It has no additional control logic available, nor provides a way of grouping fields. FieldRecord example: from rick.form import FieldRecord from rick.mixin import Translator class MyFieldRecord ( FieldRecord ): def init ( self ): self . field ( 'name' , validators = \"required|minlen:4|maxlen:8\" ) \\ . field ( 'age' , validators = \"required|numeric|between:9,125\" ) \\ . field ( 'phone' , validators = \"numeric|minlen:8|maxlen:16\" ) return self def validator_name ( self , data , t : Translator ): \"\"\" Sample custom validator for field 'name' This validator is triggered during the is_valid() call when the all the initial field validators execute successfully \"\"\" if data [ 'name' ] == 'dave' : self . add_error ( 'name' , 'Dave is not here, man' ) return False return True ( ... ) data = {} frm = MyFieldRecord () . init () if frm . is_valid ( data ): pass # do something on success else : # dump error string print ( frm . get_errors ())","title":"FieldRecord"},{"location":"requests/#form","text":"The Form class extends FieldRecord and adds grouping of fields (fieldsets), support for control elements (buttons, etc) and basic HTTP-related properties, such as action URL and HTTP method. Form example: from rick.form import Form from rick.mixin import Translator class MyForm ( Form ): def init ( self ): self . set_action ( '/user/create' ) self . set_method ( self . METHOD_POST ) # implicitly uses the default fieldset self . field ( 'text' , 'name' , 'Full Name' , validators = \"required|minlen:4|maxlen:8\" ) \\ . field ( 'text' , 'age' , 'Age' , validators = \"required|numeric|between:9,125\" ) \\ . field ( 'text' , 'phone' , 'Phone' , validators = \"numeric|minlen:8|maxlen:16\" ) # a separate fieldset self . fieldset ( 'tab2' , 'Details' ) \\ . field ( 'text' , 'address' , 'Home Address' , validators = \"required\" ) self . control ( 'submit' , 'save' , 'Save' ) \\ . control ( 'reset' , 'clear' , 'Clear Form' ) return self def validator_name ( self , data , t : Translator ): \"\"\" Sample custom validator for field 'name' This validator is triggered during the is_valid() call when the all the initial field validators execute successfully \"\"\" if data [ 'name' ] == 'dave' : self . add_error ( 'name' , 'Dave is not here, man' ) return False return True ( ... ) data = {} frm = MyForm () . init () if frm . is_valid ( data ): pass # do something on success else : # dump error string print ( frm . get_errors ())","title":"Form"},{"location":"requests/#requestrecord","text":"The RequestRecord class provides a way of declaring and validating simple field structures, suitable for eg. API usage. Fields are defined on class declaration, and there is no field grouping available, nor an initializer method. All the field-related options are available, including validators and filters. On success, field values can be accessed directly via the attributes, e.g. object.field.value. Please note: field names must not start with an underscore('_'); underscore attributes are considered private and internal to the class implementation. RequestRecord example: from rick.form import Field from rick.request import RequestRecord from rick.mixin import Translator class UserRequest ( RequestRecord ): name = Field ( validators = \"required|minlen:4|maxlen:8\" ) age = Field ( validators = \"required|numeric|between:9,125\" ) phone = Field ( validators = \"numeric|minlen:8|maxlen:16\" ) def validator_name ( self , data , t : Translator ): \"\"\" Sample custom validator for field 'name' This validator is triggered during the is_valid() call when the all the initial field validators execute successfully \"\"\" if data [ 'name' ] == 'dave' : self . add_error ( 'name' , 'Dave is not here, man' ) return False return True ( ... ) data = {} frm = UserRequest () if frm . is_valid ( data ): print ( \"User name is: {} \" . format ( frm . name . value )) else : # dump error string print ( frm . get_errors ())","title":"RequestRecord"},{"location":"filters/","text":"Filters Filter classes are helper classes used to transform a specific source value (tipically a string) into a specific data type, such as a string into a datetime object. The lifecycle of filter class objects is usually managed via a Registry, but many contexts that accept a filter name will also accept a custom filter class. These classes don't perform any validation of the passed values; if the conversion operation fails, they will silently return None. Using filters While Filters are often use within the scope of a Form, FieldRecord or RequestRecord, they can also be used in standalone: from datetime import datetime from rick.filter import registry as filter_registry # retrieve a filter to convert a string to a datetime object filter = filter_registry . get ( 'datetime' ) # use the filter to convert the string to an object result = filter . transform ( '2022-05-31T15:11Z' ) # console output: True print ( isinstance ( result , datetime )) Creating Filters Filter classes must extend the Filter base class, and implement the appropriate behaviour in the overridden transform() method: from datetime import datetime from rick.filter import registry as filter_registry , Filter from typing import Any from dataclasses import dataclass # our new Dude type @dataclass class Dude : greeting : str # add our new filter to registry, with the name 'dude' @filter_registry . register_cls ( 'dude' ) class DudeFilter ( Filter ): def transform ( self , src : Any ) -> Dude : # all values are now dude objects! return Dude ( greeting = \"Hey dude!\" ) # retrieve a filter to convert a string to a \"dude\" filter = filter_registry . get ( 'dude' ) # use the filter to convert the string to a dude result = filter . transform ( 'the quick brown fox jumps over the lazy dog' ) # console output: \"Hey Dude!\" print ( result . greeting )","title":"Filters"},{"location":"filters/#filters","text":"Filter classes are helper classes used to transform a specific source value (tipically a string) into a specific data type, such as a string into a datetime object. The lifecycle of filter class objects is usually managed via a Registry, but many contexts that accept a filter name will also accept a custom filter class. These classes don't perform any validation of the passed values; if the conversion operation fails, they will silently return None.","title":"Filters"},{"location":"filters/#using-filters","text":"While Filters are often use within the scope of a Form, FieldRecord or RequestRecord, they can also be used in standalone: from datetime import datetime from rick.filter import registry as filter_registry # retrieve a filter to convert a string to a datetime object filter = filter_registry . get ( 'datetime' ) # use the filter to convert the string to an object result = filter . transform ( '2022-05-31T15:11Z' ) # console output: True print ( isinstance ( result , datetime ))","title":"Using filters"},{"location":"filters/#creating-filters","text":"Filter classes must extend the Filter base class, and implement the appropriate behaviour in the overridden transform() method: from datetime import datetime from rick.filter import registry as filter_registry , Filter from typing import Any from dataclasses import dataclass # our new Dude type @dataclass class Dude : greeting : str # add our new filter to registry, with the name 'dude' @filter_registry . register_cls ( 'dude' ) class DudeFilter ( Filter ): def transform ( self , src : Any ) -> Dude : # all values are now dude objects! return Dude ( greeting = \"Hey dude!\" ) # retrieve a filter to convert a string to a \"dude\" filter = filter_registry . get ( 'dude' ) # use the filter to convert the string to a dude result = filter . transform ( 'the quick brown fox jumps over the lazy dog' ) # console output: \"Hey Dude!\" print ( result . greeting )","title":"Creating Filters"},{"location":"forms/","text":"Working with Forms rick.Form is a generic Form component to aid the maintenance of a form or request lifecycle. It supports the declaration of fields, field groups (fieldsets) and perform validation on those fields, including custom validation. Due to its agnostic nature, it does not provide any form rendering mechanism. Custom Validation It is possible to perform additional custom validation on a given field to be executed automatically - just add a method with the name validate_ (data, field: Field) to your class, where data will be the dict with the received values to validate, and field is the current field object for the specified field. Note: The custom validator methods are only executed if the initial validation of the form is valid (after all the specified field validators on the field definition are run and validated True ); If the form isn't valid, these methods are not executed. Custom validation method example: from rick.form import Form , Field class ExampleForm ( Form ): def init ( self ): self . field ( 'text' , 'name' , 'Name' , validators = \"required|minlen:4|maxlen:8\" ) return self def validator_name ( self , data , field : Field ): # this validator is only run if standard form validation is successful if data [ 'name' ] == 'Dave' : self . add_error ( 'name' , 'Dave is not here, man' ) return False return True frm = ExampleForm () . init () # trigger a failure on the field validators # the additional existing validator method for field 'name' won't be called valid = frm . is_valid ({ 'name' : 'Teo' }) print ( valid , frm . get_errors ()) # trigger a failure on the validation method # the field validators executed without errors valid = frm . is_valid ({ 'name' : 'Dave' }) print ( valid , frm . get_errors ()) # Console output: # False {'name': {'minlen': 'minimum allowed length is 4'}} # False {'name': {'*': 'Dave is not here, man'}} #","title":"Overview"},{"location":"forms/#working-with-forms","text":"rick.Form is a generic Form component to aid the maintenance of a form or request lifecycle. It supports the declaration of fields, field groups (fieldsets) and perform validation on those fields, including custom validation. Due to its agnostic nature, it does not provide any form rendering mechanism.","title":"Working with Forms"},{"location":"forms/#custom-validation","text":"It is possible to perform additional custom validation on a given field to be executed automatically - just add a method with the name validate_ (data, field: Field) to your class, where data will be the dict with the received values to validate, and field is the current field object for the specified field. Note: The custom validator methods are only executed if the initial validation of the form is valid (after all the specified field validators on the field definition are run and validated True ); If the form isn't valid, these methods are not executed. Custom validation method example: from rick.form import Form , Field class ExampleForm ( Form ): def init ( self ): self . field ( 'text' , 'name' , 'Name' , validators = \"required|minlen:4|maxlen:8\" ) return self def validator_name ( self , data , field : Field ): # this validator is only run if standard form validation is successful if data [ 'name' ] == 'Dave' : self . add_error ( 'name' , 'Dave is not here, man' ) return False return True frm = ExampleForm () . init () # trigger a failure on the field validators # the additional existing validator method for field 'name' won't be called valid = frm . is_valid ({ 'name' : 'Teo' }) print ( valid , frm . get_errors ()) # trigger a failure on the validation method # the field validators executed without errors valid = frm . is_valid ({ 'name' : 'Dave' }) print ( valid , frm . get_errors ()) # Console output: # False {'name': {'minlen': 'minimum allowed length is 4'}} # False {'name': {'*': 'Dave is not here, man'}} #","title":"Custom Validation"},{"location":"forms/field.class/","text":"Class rick.form. Field Base field class.","title":"Class rick.form.**Field**"},{"location":"forms/field.class/#class-rickformfield","text":"Base field class.","title":"Class rick.form.Field"},{"location":"forms/form.class/","text":"Class rick.form. Form Base form class. @property Form. fields Form field dictionary, indexed by field id. Each entry is a Field object. Form. init (translator: Translator = None) Form Constructor. Initializes the form object, and optionally receives a Translator mixin to provide translation services to all the fields and fieldsets.","title":"Form Class"},{"location":"forms/form.class/#class-rickformform","text":"Base form class.","title":"Class rick.form.Form"},{"location":"forms/form.class/#property-formfields","text":"Form field dictionary, indexed by field id. Each entry is a Field object.","title":"@property Form.fields"},{"location":"forms/form.class/#forminittranslator-translator-none","text":"Form Constructor. Initializes the form object, and optionally receives a Translator mixin to provide translation services to all the fields and fieldsets.","title":"Form.init(translator: Translator = None)"},{"location":"mixins/translator.class/","text":"Mixin rick.mixin. Translator Mixin to provide an interface for string translation Translator. t(text: str) -> str: Method signature to perform a string translation. By default, the mixin implementation returns the passed text value.","title":"Translation"},{"location":"mixins/translator.class/#mixin-rickmixintranslator","text":"Mixin to provide an interface for string translation","title":"Mixin rick.mixin.Translator"},{"location":"mixins/translator.class/#translatorttext-str-str","text":"Method signature to perform a string translation. By default, the mixin implementation returns the passed text value.","title":"Translator.t(text: str) -&gt; str:"},{"location":"validators/","text":"Validators Rick validators is a registry-based reusable approach to validation operations. It implements a programmatic approach of validating a dictionary of fields and values against a predefined validation specification. This specification can either be in dictionary format (suitable when specs are read from external sources, such as JSON), or in compact format, a string-based format based on PHP Laravel's validator specification, suitable for inline or programmatic usage. TL;DR; Example from rick.validator import Validator # a compact spec example spec_compact = { 'field1' : 'required|maxlen:3' , # field is required, maximum length is 3 'field2' : 'minlen:4' , # field is optional, minimum length is 4 'field3' : 'required|numeric|len:2,4' # field is required, must be digits, with a length between 2 and 4 } # a dict spec example spec_dict = { 'field1' : { 'required' : None , 'maxlen' : 3 , }, 'field2' : { 'minlen' : 4 , }, 'field3' : { 'required' : None , 'numeric' : None , 'len' : [ 2 , 4 ], } } # field data dict to perform validation on fields_values = { 'field1' : 'abc' , 'field2' : 'def' , 'field3' : 12345 } # validate compact notation v = Validator ( spec_compact ) # perform validation, should return False with errors in field2 and field3 valid = v . is_valid ( fields_values ) # # console output: # False {'field2': {'minlen': 'minimum allowed length is 4'}, 'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ()) # validate with dict notation v = Validator ( spec_dict ) # perform validation, should return False with errors in field2 and field3 valid = v . is_valid ( fields_values ) # # console output: # False {'field2': {'minlen': 'minimum allowed length is 4'}, 'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ()) # retrieve errors for specific fields # # console output: {'minlen': 'minimum allowed length is 4'} print ( v . get_errors ( 'field2' )) # # console output: {'len': 'length must be between [2, 4]'} print ( v . get_errors ( 'field3' )) # Simulate optional field - remove field2 from value dictionary # the validation result should fail, but without any error for field2, because its absent fields_values . pop ( 'field2' ) valid = v . is_valid ( fields_values ) # # console output: # False {'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ()) Specification: Dict format The dict format spectification is a 2-level dictionary, where the first level keys are field names, and the second level keys are validator names and optional parameters. Example of a dict format specification with 2 validators, one of them ( len ) with validator parameters: spec = { 'field_name' : { 'required' : None , 'len' :[ 2 , 4 ] } } Specification: Compact format The compact format specification is a string with one or several validator names concatenated with '|'. Some validators require one or more parameters; these are specified as a comma-separared list after a ':' following the validator name. Example of a compact format specification with 2 validators, one of them ( len ) with validator parameters: spec = { 'field_name' : 'required|len:2,4' } Available validators The complete list of available validators is available here . Optional fields and aborting on first fail Chaining validators Validator Class Adding custom Validators","title":"Overview"},{"location":"validators/#validators","text":"Rick validators is a registry-based reusable approach to validation operations. It implements a programmatic approach of validating a dictionary of fields and values against a predefined validation specification. This specification can either be in dictionary format (suitable when specs are read from external sources, such as JSON), or in compact format, a string-based format based on PHP Laravel's validator specification, suitable for inline or programmatic usage.","title":"Validators"},{"location":"validators/#tldr-example","text":"from rick.validator import Validator # a compact spec example spec_compact = { 'field1' : 'required|maxlen:3' , # field is required, maximum length is 3 'field2' : 'minlen:4' , # field is optional, minimum length is 4 'field3' : 'required|numeric|len:2,4' # field is required, must be digits, with a length between 2 and 4 } # a dict spec example spec_dict = { 'field1' : { 'required' : None , 'maxlen' : 3 , }, 'field2' : { 'minlen' : 4 , }, 'field3' : { 'required' : None , 'numeric' : None , 'len' : [ 2 , 4 ], } } # field data dict to perform validation on fields_values = { 'field1' : 'abc' , 'field2' : 'def' , 'field3' : 12345 } # validate compact notation v = Validator ( spec_compact ) # perform validation, should return False with errors in field2 and field3 valid = v . is_valid ( fields_values ) # # console output: # False {'field2': {'minlen': 'minimum allowed length is 4'}, 'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ()) # validate with dict notation v = Validator ( spec_dict ) # perform validation, should return False with errors in field2 and field3 valid = v . is_valid ( fields_values ) # # console output: # False {'field2': {'minlen': 'minimum allowed length is 4'}, 'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ()) # retrieve errors for specific fields # # console output: {'minlen': 'minimum allowed length is 4'} print ( v . get_errors ( 'field2' )) # # console output: {'len': 'length must be between [2, 4]'} print ( v . get_errors ( 'field3' )) # Simulate optional field - remove field2 from value dictionary # the validation result should fail, but without any error for field2, because its absent fields_values . pop ( 'field2' ) valid = v . is_valid ( fields_values ) # # console output: # False {'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ())","title":"TL;DR; Example"},{"location":"validators/#specification-dict-format","text":"The dict format spectification is a 2-level dictionary, where the first level keys are field names, and the second level keys are validator names and optional parameters. Example of a dict format specification with 2 validators, one of them ( len ) with validator parameters: spec = { 'field_name' : { 'required' : None , 'len' :[ 2 , 4 ] } }","title":"Specification: Dict format"},{"location":"validators/#specification-compact-format","text":"The compact format specification is a string with one or several validator names concatenated with '|'. Some validators require one or more parameters; these are specified as a comma-separared list after a ':' following the validator name. Example of a compact format specification with 2 validators, one of them ( len ) with validator parameters: spec = { 'field_name' : 'required|len:2,4' }","title":"Specification: Compact format"},{"location":"validators/#available-validators","text":"The complete list of available validators is available here .","title":"Available validators"},{"location":"validators/#optional-fields-and-aborting-on-first-fail","text":"","title":"Optional fields and aborting on first fail"},{"location":"validators/#chaining-validators","text":"","title":"Chaining validators"},{"location":"validators/#validator-class","text":"","title":"Validator Class"},{"location":"validators/#adding-custom-validators","text":"","title":"Adding custom Validators"},{"location":"validators/validator_list/","text":"Available validators General Validators Name Parameters Description required Value is required bail Special validator to skip running all validators on failure id Value must be a positive numeric greater than 0 uuid Value must be a valid UUID notempty Value must not be empty in list,of,values... Value must be in the specified list of values notin list,of,values... Value must not be in the specified list of values strin list,of,values... Value is a string and must be in the specified list of values strnotin list,of,values... Value is a string and must not be in the specified list of values bool Value must be a valid bool representation: 0, 1, y, t, true, n, f, false iso8601 Value must be a valid iso8601 date string String Validators Name Parameters Description alpha Value must contain only letters a-z and A-Z alphanum Value must contain only letters a-z and A-Z or digits 0-9 slug Value must be an alphanum string, but that can contain '-' and '_' len min,max Value char length must be between min and max minlen min Value char length must be at least min chars maxlen max Value char length must be upto max chars List Validators Name Parameters Description list Value must be a list of items listlen min[, max]] Item list must have at least min elements and optionally max elements Numeric Validators Name Parameters Description between min,max Value must be numeric between min and max; Floats are supported numeric Value must be a numeral (digits only) decimal Value must be a valid decimal numeral Network Validators Name Parameters Description ipv4 Value must be a valid IPv4 address ipv6 Value must be a valid IPv6 address ip Value must be a valid IPv4 or IPv6 address fqdn Value must be a valid fqdn (fully qualified domain name) email Value must be a valid email address mac Value must be a valid MAC address Hash Validators Name Parameters Description md5 Value must be a valid MD5 hash sha1 Value must be a valid SHA1 hash sha256 Value must be a valid SHA256 hash sha512 Value must be a valid SHA512 hash","title":"Available Validators"},{"location":"validators/validator_list/#available-validators","text":"","title":"Available validators"},{"location":"validators/validator_list/#general-validators","text":"Name Parameters Description required Value is required bail Special validator to skip running all validators on failure id Value must be a positive numeric greater than 0 uuid Value must be a valid UUID notempty Value must not be empty in list,of,values... Value must be in the specified list of values notin list,of,values... Value must not be in the specified list of values strin list,of,values... Value is a string and must be in the specified list of values strnotin list,of,values... Value is a string and must not be in the specified list of values bool Value must be a valid bool representation: 0, 1, y, t, true, n, f, false iso8601 Value must be a valid iso8601 date string","title":"General Validators"},{"location":"validators/validator_list/#string-validators","text":"Name Parameters Description alpha Value must contain only letters a-z and A-Z alphanum Value must contain only letters a-z and A-Z or digits 0-9 slug Value must be an alphanum string, but that can contain '-' and '_' len min,max Value char length must be between min and max minlen min Value char length must be at least min chars maxlen max Value char length must be upto max chars","title":"String Validators"},{"location":"validators/validator_list/#list-validators","text":"Name Parameters Description list Value must be a list of items listlen min[, max]] Item list must have at least min elements and optionally max elements","title":"List Validators"},{"location":"validators/validator_list/#numeric-validators","text":"Name Parameters Description between min,max Value must be numeric between min and max; Floats are supported numeric Value must be a numeral (digits only) decimal Value must be a valid decimal numeral","title":"Numeric Validators"},{"location":"validators/validator_list/#network-validators","text":"Name Parameters Description ipv4 Value must be a valid IPv4 address ipv6 Value must be a valid IPv6 address ip Value must be a valid IPv4 or IPv6 address fqdn Value must be a valid fqdn (fully qualified domain name) email Value must be a valid email address mac Value must be a valid MAC address","title":"Network Validators"},{"location":"validators/validator_list/#hash-validators","text":"Name Parameters Description md5 Value must be a valid MD5 hash sha1 Value must be a valid SHA1 hash sha256 Value must be a valid SHA256 hash sha512 Value must be a valid SHA512 hash","title":"Hash Validators"}]}