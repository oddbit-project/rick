{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Rick Rick is a plumbing library for micro framework design. It provides base classes for miscellaneous purposes, ranging from dependency injection to validation. However, it does not include any HTTP/{A,W}SGI functionality, nor any database-related functionality; you should instead using other existing projects for that functionality, such as Flask for MVC and RickDb for database operations. Components Dependency Injection (DI) class; Container class; Generic resource map loader class; Registry class; Cache interface; REDIS cache client; AES256 crypto functions for cache mechanisms; Event manager; Request validator ; Form management Validation classes ; Filters","title":"Overview"},{"location":"#welcome-to-rick","text":"Rick is a plumbing library for micro framework design. It provides base classes for miscellaneous purposes, ranging from dependency injection to validation. However, it does not include any HTTP/{A,W}SGI functionality, nor any database-related functionality; you should instead using other existing projects for that functionality, such as Flask for MVC and RickDb for database operations.","title":"Welcome to Rick"},{"location":"#components","text":"Dependency Injection (DI) class; Container class; Generic resource map loader class; Registry class; Cache interface; REDIS cache client; AES256 crypto functions for cache mechanisms; Event manager; Request validator ; Form management Validation classes ; Filters","title":"Components"},{"location":"filters/","text":"Filters Filter classes are helper classes used to transform a specific source value (tipically a string) into a specific data type, such as a string into a datetime object. The lifecycle of filter class objects is usually managed via a Registry, but many contexts that accept a filter name will also accept a custom filter class. These classes don't perform any validation of the passed values; if the conversion operation fails, they will silently return None. Using filters While Filters are often use within the scope of a Form, FieldRecord or RequestRecord, they can also be used in standalone: from datetime import datetime from rick.filter import registry as filter_registry # retrieve a filter to convert a string to a datetime object filter = filter_registry . get ( 'datetime' ) # use the filter to convert the string to an object result = filter . transform ( '2022-05-31T15:11Z' ) # console output: True print ( isinstance ( result , datetime )) Creating Filters Filter classes must extend the Filter base class, and implement the appropriate behaviour in the overridden transform() method: from datetime import datetime from rick.filter import registry as filter_registry , Filter from typing import Any from dataclasses import dataclass # our new Dude type @dataclass class Dude : greeting : str # add our new filter to registry, with the name 'dude' @filter_registry . register_cls ( 'dude' ) class DudeFilter ( Filter ): def transform ( self , src : Any ) -> Dude : # all values are now dude objects! return Dude ( greeting = \"Hey dude!\" ) # retrieve a filter to convert a string to a \"dude\" filter = filter_registry . get ( 'dude' ) # use the filter to convert the string to a dude result = filter . transform ( 'the quick brown fox jumps over the lazy dog' ) # console output: \"Hey Dude!\" print ( result . greeting )","title":"Filters"},{"location":"filters/#filters","text":"Filter classes are helper classes used to transform a specific source value (tipically a string) into a specific data type, such as a string into a datetime object. The lifecycle of filter class objects is usually managed via a Registry, but many contexts that accept a filter name will also accept a custom filter class. These classes don't perform any validation of the passed values; if the conversion operation fails, they will silently return None.","title":"Filters"},{"location":"filters/#using-filters","text":"While Filters are often use within the scope of a Form, FieldRecord or RequestRecord, they can also be used in standalone: from datetime import datetime from rick.filter import registry as filter_registry # retrieve a filter to convert a string to a datetime object filter = filter_registry . get ( 'datetime' ) # use the filter to convert the string to an object result = filter . transform ( '2022-05-31T15:11Z' ) # console output: True print ( isinstance ( result , datetime ))","title":"Using filters"},{"location":"filters/#creating-filters","text":"Filter classes must extend the Filter base class, and implement the appropriate behaviour in the overridden transform() method: from datetime import datetime from rick.filter import registry as filter_registry , Filter from typing import Any from dataclasses import dataclass # our new Dude type @dataclass class Dude : greeting : str # add our new filter to registry, with the name 'dude' @filter_registry . register_cls ( 'dude' ) class DudeFilter ( Filter ): def transform ( self , src : Any ) -> Dude : # all values are now dude objects! return Dude ( greeting = \"Hey dude!\" ) # retrieve a filter to convert a string to a \"dude\" filter = filter_registry . get ( 'dude' ) # use the filter to convert the string to a dude result = filter . transform ( 'the quick brown fox jumps over the lazy dog' ) # console output: \"Hey Dude!\" print ( result . greeting )","title":"Creating Filters"},{"location":"forms/","text":"Working with Forms rick.Form is a generic Form component to aid the maintenance of a form or request lifecycle. It supports the declaration of fields, field groups (fieldsets) and perform validation on those fields, including custom validation. Due to its agnostic nature, it does not provide any form rendering mechanism. Custom Validation It is possible to perform additional custom validation on a given field to be executed automatically - just add a method with the name validate_ (data, field: Field) to your class, where data will be the dict with the received values to validate, and field is the current field object for the specified field. Note: The custom validator methods are only executed if the initial validation of the form is valid (after all the specified field validators on the field definition are run and validated True ); If the form isn't valid, these methods are not executed. Custom validation method example: from rick.form import Form , Field class ExampleForm ( Form ): def init ( self ): self . field ( 'text' , 'name' , 'Name' , validators = \"required|minlen:4|maxlen:8\" ) return self def validator_name ( self , data , field : Field ): # this validator is only run if standard form validation is successful if data [ 'name' ] == 'Dave' : self . add_error ( 'name' , 'Dave is not here, man' ) return False return True frm = ExampleForm () . init () # trigger a failure on the field validators # the additional existing validator method for field 'name' won't be called valid = frm . is_valid ({ 'name' : 'Teo' }) print ( valid , frm . get_errors ()) # trigger a failure on the validation method # the field validators executed without errors valid = frm . is_valid ({ 'name' : 'Dave' }) print ( valid , frm . get_errors ()) # Console output: # False {'name': {'minlen': 'minimum allowed length is 4'}} # False {'name': {'*': 'Dave is not here, man'}} #","title":"Overview"},{"location":"forms/#working-with-forms","text":"rick.Form is a generic Form component to aid the maintenance of a form or request lifecycle. It supports the declaration of fields, field groups (fieldsets) and perform validation on those fields, including custom validation. Due to its agnostic nature, it does not provide any form rendering mechanism.","title":"Working with Forms"},{"location":"forms/#custom-validation","text":"It is possible to perform additional custom validation on a given field to be executed automatically - just add a method with the name validate_ (data, field: Field) to your class, where data will be the dict with the received values to validate, and field is the current field object for the specified field. Note: The custom validator methods are only executed if the initial validation of the form is valid (after all the specified field validators on the field definition are run and validated True ); If the form isn't valid, these methods are not executed. Custom validation method example: from rick.form import Form , Field class ExampleForm ( Form ): def init ( self ): self . field ( 'text' , 'name' , 'Name' , validators = \"required|minlen:4|maxlen:8\" ) return self def validator_name ( self , data , field : Field ): # this validator is only run if standard form validation is successful if data [ 'name' ] == 'Dave' : self . add_error ( 'name' , 'Dave is not here, man' ) return False return True frm = ExampleForm () . init () # trigger a failure on the field validators # the additional existing validator method for field 'name' won't be called valid = frm . is_valid ({ 'name' : 'Teo' }) print ( valid , frm . get_errors ()) # trigger a failure on the validation method # the field validators executed without errors valid = frm . is_valid ({ 'name' : 'Dave' }) print ( valid , frm . get_errors ()) # Console output: # False {'name': {'minlen': 'minimum allowed length is 4'}} # False {'name': {'*': 'Dave is not here, man'}} #","title":"Custom Validation"},{"location":"forms/errors/","text":"RequestRecord/Form error messages RequestRecord and form error messages have the following structure: { field_name: { validator_name: error_message, validator_name: error_message }, field-name: {...} } Where field_name is the field id, and validator_name either the name of the failing validator, or '*' for generic error messages for the field. Example result, with two failing validations on a single field: { \"age\" : { \"between\" : \"must be between 9 and 125\" , \"numeric\" : \"only digits allowed\" } } Nested Records Nested record errors are signaled by using '_' as validator name. The nested record can either be a single record, or a list of records: Structure for single record: { field_name: { validator_name: error_message, validator_name: error_message }, field-name: { validator_name: error_message, \"_\": { field_name: { validator_name: error_message, validator_name: error_message, }, field_name: { validator_name: error_message, validator_name: error_message, }, } } } Structure for a list of records (notice the sequence number to identify the failing record position): { field_name: { validator_name: error_message, validator_name: error_message }, field-name: { validator_name: error_message, \"_\": { \"sequence number\": { field_name: { validator_name: error_message, validator_name: error_message, }, field_name: { validator_name: error_message, validator_name: error_message, }, } } } }","title":"RequestRecord/Form error messages"},{"location":"forms/errors/#requestrecordform-error-messages","text":"RequestRecord and form error messages have the following structure: { field_name: { validator_name: error_message, validator_name: error_message }, field-name: {...} } Where field_name is the field id, and validator_name either the name of the failing validator, or '*' for generic error messages for the field. Example result, with two failing validations on a single field: { \"age\" : { \"between\" : \"must be between 9 and 125\" , \"numeric\" : \"only digits allowed\" } }","title":"RequestRecord/Form error messages"},{"location":"forms/errors/#nested-records","text":"Nested record errors are signaled by using '_' as validator name. The nested record can either be a single record, or a list of records: Structure for single record: { field_name: { validator_name: error_message, validator_name: error_message }, field-name: { validator_name: error_message, \"_\": { field_name: { validator_name: error_message, validator_name: error_message, }, field_name: { validator_name: error_message, validator_name: error_message, }, } } } Structure for a list of records (notice the sequence number to identify the failing record position): { field_name: { validator_name: error_message, validator_name: error_message }, field-name: { validator_name: error_message, \"_\": { \"sequence number\": { field_name: { validator_name: error_message, validator_name: error_message, }, field_name: { validator_name: error_message, validator_name: error_message, }, } } } }","title":"Nested Records"},{"location":"forms/field.class/","text":"Class rick.form. Field Base field class.","title":"Class rick.form.**Field**"},{"location":"forms/field.class/#class-rickformfield","text":"Base field class.","title":"Class rick.form.Field"},{"location":"forms/form.class/","text":"Class rick.form. Form Base form class. @property Form. fields Form field dictionary, indexed by field id. Each entry is a Field object. Form. init (translator: Translator = None) Form Constructor. Initializes the form object, and optionally receives a Translator mixin to provide translation services to all the fields and fieldsets.","title":"Form Class"},{"location":"forms/form.class/#class-rickformform","text":"Base form class.","title":"Class rick.form.Form"},{"location":"forms/form.class/#property-formfields","text":"Form field dictionary, indexed by field id. Each entry is a Field object.","title":"@property Form.fields"},{"location":"forms/form.class/#forminittranslator-translator-none","text":"Form Constructor. Initializes the form object, and optionally receives a Translator mixin to provide translation services to all the fields and fieldsets.","title":"Form.init(translator: Translator = None)"},{"location":"forms/requests/","text":"Managing Requests Rick provides several distinct classes to aid the management of request data: RequestRecord and Form . While these classes share a common syntax, their use cases are different. RequestRecord is designed to just handle structured request data; Form extends RequestRecord with additional control and grouping logic, useful for generating and processing HTML forms. RequestRecord RequestRecord provides two ways for defining fields and field-related validation and filtering operations; A terse version, suitable for most usage scenarios, where the fields are specified directly in the class declaration (via fields attribute), or in runtime by using an initializer method, often called init(). Declaring fields directly using class attributes: from rick.form import RequestRecord , field class UserRequest ( RequestRecord ): fields = { 'id' : field ( validators = \"numeric\" ), 'name' : field ( validators = \"required|maxlen:128\" ), 'age' : field ( validators = \"required|numeric|between:18,120\" ) } Declaring fields inside an initializer method: from rick.form import RequestRecord from rick.mixin import Translator # Custom class using runtime field definitions, and a custom field validator class UserRequest ( RequestRecord ): def init ( self ): self . field ( 'id' , validators = \"required|minlen:4|maxlen:8\" ) \\ . field ( 'age' , validators = \"required|numeric|between:9,125\" ) \\ . field ( 'phone' , validators = \"numeric|minlen:8|maxlen:16\" ) return self RequestRecord validation There are two levels of validation: a first one, using the declared validators, and a second one using optional methods to perform additional validation. Validation of data is done by using RequestRecord's is_valid() method. This method receives a dictionary of field names and values, and returns either True or False, reflecting if all the values for the defined fields pass the predefined validators or not, as well as the optional validation methods. Note: internally, the validation is performed as a two-step operation - if any of the declared field validators fail validation, no magic validation methods are called. Magic validation methods will only be executed for any given field if all the predefined field validations pass. The rationale for this is to avoid having to perform basic validations within the method body, simplifying the implementation of additional validation logic. This way, when any magic method is called, it is guaranteed that the available data passed the field validations. Field validators field validators can be specified using any format compatible with rick.Validator usage, but commonly will use the string Laravel-style compact form: from rick.form import RequestRecord , field class AgeRequest ( RequestRecord ): fields = { # age field with several validators 'age' : field ( validators = \"required|numeric|between:18,120\" ) } # create the request validation object to be used req = AgeRequest () # some invalid data to fail validation data = { 'name' : 'John Connor' , 'age' : '1a' } # validate data, should fail if not req . is_valid ( data ): # will print: # {'age': {'numeric': 'only digits allowed', 'between': 'must be between 18 and 120'}} print ( req . get_errors ()) Each failing validator will generate an error message; it is possible to override all error messages for a given field by just providing a custom error message: from rick.form import RequestRecord , field class AgeRequest ( RequestRecord ): fields = { # age field with several validators 'age' : field ( validators = \"required|numeric|between:18,120\" , error = \"invalid age\" ) } # create the request validation object to be used req = AgeRequest () # some invalid data to fail validation data = { 'name' : 'John Connor' , 'age' : '1a' } # validate data, should fail if not req . is_valid ( data ): # will print: # {'age': {'*': 'invalid age'}} print ( req . get_errors ()) Method validators As mentioned, RequestRecord allows for the optional declaration of magic validation methods that are called automatically during the internal second validation step. These methods can be used to perform additional validation logic, such as dependencies between fields or database lookups. The methods must be named validator_ (data, t:Translator) and conform to the defined interface: from rick.form import RequestRecord , field from rick.mixin import Translator # Custom class using runtime field definitions, and a custom field validator class MyFieldRecord ( RequestRecord ): fields = { 'name' : field ( validators = \"required|minlen:4|maxlen:8\" ), 'age' : field ( validators = \"required|numeric|between:9,125\" ), 'phone' : field ( validators = \"numeric|minlen:8|maxlen:16\" ) } # custom validator method for field 'name' # this will only be executed if all field validators are successful def validator_name ( self , data , t : Translator ): # 'data' is the field:value dictionary passed to is_valid(); it # contains all raw field values if data [ 'name' ] == 'dave' : # add a custom error for field 'name' self . add_error ( 'name' , 'Dave is not here, man' ) return False return True data = { 'name' : 'dave' , 'age' : 12 , 'phone' : '12312312' } frm = MyFieldRecord () if not frm . is_valid ( data ): # will print: # {'name': {'*': 'Dave is not here, man'}} print ( frm . get_errors ()) Retrieving validation errors Validation errors are made available via get_errors() , using the documented format . Nested RequestRecord structures RequestRecord classes can be nested to build complex request validation structures. This can be achieved using the record() helper function to describe dict-like records, or recordset() helper function to describe lists of dict-like records. Internally, records are also represented as fields, so filtered values can be accessed like any other regular field. Example: from rick.form import RequestRecord , field , record , recordset from rick.mixin import Translator # Request class describing a player structure class Player ( RequestRecord ): fields = { 'name' : field ( validators = \"required|minlen:4|maxlen:32\" ), 'age' : field ( validators = \"required|numeric|between:9,125\" ), } # Request class for a team class TeamRequest ( RequestRecord ): fields = { 'team_name' : field ( validators = \"required|minlen:4|maxlen:64\" ), # specify a field 'players' as a list of type Player, for validation purposes 'players' : recordset ( Player ) } # Request class for a team leader class TeamLeaderRequest ( RequestRecord ): fields = { 'team_name' : field ( validators = \"required|minlen:4|maxlen:64\" ), # specify a field 'players' as a single record of type Player, for validation purposes 'leader' : record ( Player ) } # sample request data for TeamRequest team_data = { 'team_name' : 'super team' , 'players' : [ { 'name' : 'susan' , 'age' : 32 }, { 'name' : 'mary' , 'age' : 21 }, ] } # validate data for TeamRequest request = TeamRequest () if request . is_valid ( team_data ): print ( 'Team data is valid!' ) # sample request data for TeamLeaderRequest team_leader_data = { 'team_name' : 'super team' , 'leader' : { 'name' : 'susan' , 'age' : 32 } } # validate data for TeamLeaderRequest request = TeamLeaderRequest () if request . is_valid ( team_leader_data ): print ( 'Team leader data is valid!' )","title":"Requests"},{"location":"forms/requests/#managing-requests","text":"Rick provides several distinct classes to aid the management of request data: RequestRecord and Form . While these classes share a common syntax, their use cases are different. RequestRecord is designed to just handle structured request data; Form extends RequestRecord with additional control and grouping logic, useful for generating and processing HTML forms.","title":"Managing Requests"},{"location":"forms/requests/#requestrecord","text":"RequestRecord provides two ways for defining fields and field-related validation and filtering operations; A terse version, suitable for most usage scenarios, where the fields are specified directly in the class declaration (via fields attribute), or in runtime by using an initializer method, often called init(). Declaring fields directly using class attributes: from rick.form import RequestRecord , field class UserRequest ( RequestRecord ): fields = { 'id' : field ( validators = \"numeric\" ), 'name' : field ( validators = \"required|maxlen:128\" ), 'age' : field ( validators = \"required|numeric|between:18,120\" ) } Declaring fields inside an initializer method: from rick.form import RequestRecord from rick.mixin import Translator # Custom class using runtime field definitions, and a custom field validator class UserRequest ( RequestRecord ): def init ( self ): self . field ( 'id' , validators = \"required|minlen:4|maxlen:8\" ) \\ . field ( 'age' , validators = \"required|numeric|between:9,125\" ) \\ . field ( 'phone' , validators = \"numeric|minlen:8|maxlen:16\" ) return self","title":"RequestRecord"},{"location":"forms/requests/#requestrecord-validation","text":"There are two levels of validation: a first one, using the declared validators, and a second one using optional methods to perform additional validation. Validation of data is done by using RequestRecord's is_valid() method. This method receives a dictionary of field names and values, and returns either True or False, reflecting if all the values for the defined fields pass the predefined validators or not, as well as the optional validation methods. Note: internally, the validation is performed as a two-step operation - if any of the declared field validators fail validation, no magic validation methods are called. Magic validation methods will only be executed for any given field if all the predefined field validations pass. The rationale for this is to avoid having to perform basic validations within the method body, simplifying the implementation of additional validation logic. This way, when any magic method is called, it is guaranteed that the available data passed the field validations.","title":"RequestRecord validation"},{"location":"forms/requests/#field-validators","text":"field validators can be specified using any format compatible with rick.Validator usage, but commonly will use the string Laravel-style compact form: from rick.form import RequestRecord , field class AgeRequest ( RequestRecord ): fields = { # age field with several validators 'age' : field ( validators = \"required|numeric|between:18,120\" ) } # create the request validation object to be used req = AgeRequest () # some invalid data to fail validation data = { 'name' : 'John Connor' , 'age' : '1a' } # validate data, should fail if not req . is_valid ( data ): # will print: # {'age': {'numeric': 'only digits allowed', 'between': 'must be between 18 and 120'}} print ( req . get_errors ()) Each failing validator will generate an error message; it is possible to override all error messages for a given field by just providing a custom error message: from rick.form import RequestRecord , field class AgeRequest ( RequestRecord ): fields = { # age field with several validators 'age' : field ( validators = \"required|numeric|between:18,120\" , error = \"invalid age\" ) } # create the request validation object to be used req = AgeRequest () # some invalid data to fail validation data = { 'name' : 'John Connor' , 'age' : '1a' } # validate data, should fail if not req . is_valid ( data ): # will print: # {'age': {'*': 'invalid age'}} print ( req . get_errors ())","title":"Field validators"},{"location":"forms/requests/#method-validators","text":"As mentioned, RequestRecord allows for the optional declaration of magic validation methods that are called automatically during the internal second validation step. These methods can be used to perform additional validation logic, such as dependencies between fields or database lookups. The methods must be named validator_ (data, t:Translator) and conform to the defined interface: from rick.form import RequestRecord , field from rick.mixin import Translator # Custom class using runtime field definitions, and a custom field validator class MyFieldRecord ( RequestRecord ): fields = { 'name' : field ( validators = \"required|minlen:4|maxlen:8\" ), 'age' : field ( validators = \"required|numeric|between:9,125\" ), 'phone' : field ( validators = \"numeric|minlen:8|maxlen:16\" ) } # custom validator method for field 'name' # this will only be executed if all field validators are successful def validator_name ( self , data , t : Translator ): # 'data' is the field:value dictionary passed to is_valid(); it # contains all raw field values if data [ 'name' ] == 'dave' : # add a custom error for field 'name' self . add_error ( 'name' , 'Dave is not here, man' ) return False return True data = { 'name' : 'dave' , 'age' : 12 , 'phone' : '12312312' } frm = MyFieldRecord () if not frm . is_valid ( data ): # will print: # {'name': {'*': 'Dave is not here, man'}} print ( frm . get_errors ())","title":"Method validators"},{"location":"forms/requests/#retrieving-validation-errors","text":"Validation errors are made available via get_errors() , using the documented format .","title":"Retrieving validation errors"},{"location":"forms/requests/#nested-requestrecord-structures","text":"RequestRecord classes can be nested to build complex request validation structures. This can be achieved using the record() helper function to describe dict-like records, or recordset() helper function to describe lists of dict-like records. Internally, records are also represented as fields, so filtered values can be accessed like any other regular field. Example: from rick.form import RequestRecord , field , record , recordset from rick.mixin import Translator # Request class describing a player structure class Player ( RequestRecord ): fields = { 'name' : field ( validators = \"required|minlen:4|maxlen:32\" ), 'age' : field ( validators = \"required|numeric|between:9,125\" ), } # Request class for a team class TeamRequest ( RequestRecord ): fields = { 'team_name' : field ( validators = \"required|minlen:4|maxlen:64\" ), # specify a field 'players' as a list of type Player, for validation purposes 'players' : recordset ( Player ) } # Request class for a team leader class TeamLeaderRequest ( RequestRecord ): fields = { 'team_name' : field ( validators = \"required|minlen:4|maxlen:64\" ), # specify a field 'players' as a single record of type Player, for validation purposes 'leader' : record ( Player ) } # sample request data for TeamRequest team_data = { 'team_name' : 'super team' , 'players' : [ { 'name' : 'susan' , 'age' : 32 }, { 'name' : 'mary' , 'age' : 21 }, ] } # validate data for TeamRequest request = TeamRequest () if request . is_valid ( team_data ): print ( 'Team data is valid!' ) # sample request data for TeamLeaderRequest team_leader_data = { 'team_name' : 'super team' , 'leader' : { 'name' : 'susan' , 'age' : 32 } } # validate data for TeamLeaderRequest request = TeamLeaderRequest () if request . is_valid ( team_leader_data ): print ( 'Team leader data is valid!' )","title":"Nested RequestRecord structures"},{"location":"mixins/translator.class/","text":"Mixin rick.mixin. Translator Mixin to provide an interface for string translation Translator. t(text: str) -> str: Method signature to perform a string translation. By default, the mixin implementation returns the passed text value.","title":"Translation"},{"location":"mixins/translator.class/#mixin-rickmixintranslator","text":"Mixin to provide an interface for string translation","title":"Mixin rick.mixin.Translator"},{"location":"mixins/translator.class/#translatorttext-str-str","text":"Method signature to perform a string translation. By default, the mixin implementation returns the passed text value.","title":"Translator.t(text: str) -&gt; str:"},{"location":"validators/","text":"Validators Rick validators is a registry-based reusable approach to validation operations. It implements a programmatic approach of validating a dictionary of fields and values against a predefined validation specification. This specification can either be in dictionary format (suitable when specs are read from external sources, such as JSON), or in compact format, a string-based format based on PHP Laravel's validator specification, suitable for inline or programmatic usage. TL;DR; Example from rick.validator import Validator # a compact spec example spec_compact = { 'field1' : 'required|maxlen:3' , # field is required, maximum length is 3 'field2' : 'minlen:4' , # field is optional, minimum length is 4 'field3' : 'required|numeric|len:2,4' # field is required, must be digits, with a length between 2 and 4 } # a dict spec example spec_dict = { 'field1' : { 'required' : None , 'maxlen' : 3 , }, 'field2' : { 'minlen' : 4 , }, 'field3' : { 'required' : None , 'numeric' : None , 'len' : [ 2 , 4 ], } } # field data dict to perform validation on fields_values = { 'field1' : 'abc' , 'field2' : 'def' , 'field3' : 12345 } # validate compact notation v = Validator ( spec_compact ) # perform validation, should return False with errors in field2 and field3 valid = v . is_valid ( fields_values ) # # console output: # False {'field2': {'minlen': 'minimum allowed length is 4'}, 'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ()) # validate with dict notation v = Validator ( spec_dict ) # perform validation, should return False with errors in field2 and field3 valid = v . is_valid ( fields_values ) # # console output: # False {'field2': {'minlen': 'minimum allowed length is 4'}, 'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ()) # retrieve errors for specific fields # # console output: {'minlen': 'minimum allowed length is 4'} print ( v . get_errors ( 'field2' )) # # console output: {'len': 'length must be between [2, 4]'} print ( v . get_errors ( 'field3' )) # Simulate optional field - remove field2 from value dictionary # the validation result should fail, but without any error for field2, because its absent fields_values . pop ( 'field2' ) valid = v . is_valid ( fields_values ) # # console output: # False {'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ()) Specification: Dict format The dict format spectification is a 2-level dictionary, where the first level keys are field names, and the second level keys are validator names and optional parameters. Example of a dict format specification with 2 validators, one of them ( len ) with validator parameters: spec = { 'field_name' : { 'required' : None , 'len' :[ 2 , 4 ] } } Specification: Compact format The compact format specification is a string with one or several validator names concatenated with '|'. Some validators require one or more parameters; these are specified as a comma-separared list after a ':' following the validator name. Example of a compact format specification with 2 validators, one of them ( len ) with validator parameters: spec = { 'field_name' : 'required|len:2,4' } Available validators The complete list of available validators is available here . Optional fields and aborting on first fail Chaining validators Validator Class Adding custom Validators","title":"Overview"},{"location":"validators/#validators","text":"Rick validators is a registry-based reusable approach to validation operations. It implements a programmatic approach of validating a dictionary of fields and values against a predefined validation specification. This specification can either be in dictionary format (suitable when specs are read from external sources, such as JSON), or in compact format, a string-based format based on PHP Laravel's validator specification, suitable for inline or programmatic usage.","title":"Validators"},{"location":"validators/#tldr-example","text":"from rick.validator import Validator # a compact spec example spec_compact = { 'field1' : 'required|maxlen:3' , # field is required, maximum length is 3 'field2' : 'minlen:4' , # field is optional, minimum length is 4 'field3' : 'required|numeric|len:2,4' # field is required, must be digits, with a length between 2 and 4 } # a dict spec example spec_dict = { 'field1' : { 'required' : None , 'maxlen' : 3 , }, 'field2' : { 'minlen' : 4 , }, 'field3' : { 'required' : None , 'numeric' : None , 'len' : [ 2 , 4 ], } } # field data dict to perform validation on fields_values = { 'field1' : 'abc' , 'field2' : 'def' , 'field3' : 12345 } # validate compact notation v = Validator ( spec_compact ) # perform validation, should return False with errors in field2 and field3 valid = v . is_valid ( fields_values ) # # console output: # False {'field2': {'minlen': 'minimum allowed length is 4'}, 'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ()) # validate with dict notation v = Validator ( spec_dict ) # perform validation, should return False with errors in field2 and field3 valid = v . is_valid ( fields_values ) # # console output: # False {'field2': {'minlen': 'minimum allowed length is 4'}, 'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ()) # retrieve errors for specific fields # # console output: {'minlen': 'minimum allowed length is 4'} print ( v . get_errors ( 'field2' )) # # console output: {'len': 'length must be between [2, 4]'} print ( v . get_errors ( 'field3' )) # Simulate optional field - remove field2 from value dictionary # the validation result should fail, but without any error for field2, because its absent fields_values . pop ( 'field2' ) valid = v . is_valid ( fields_values ) # # console output: # False {'field3': {'len': 'length must be between [2, 4]'}} print ( valid , v . get_errors ())","title":"TL;DR; Example"},{"location":"validators/#specification-dict-format","text":"The dict format spectification is a 2-level dictionary, where the first level keys are field names, and the second level keys are validator names and optional parameters. Example of a dict format specification with 2 validators, one of them ( len ) with validator parameters: spec = { 'field_name' : { 'required' : None , 'len' :[ 2 , 4 ] } }","title":"Specification: Dict format"},{"location":"validators/#specification-compact-format","text":"The compact format specification is a string with one or several validator names concatenated with '|'. Some validators require one or more parameters; these are specified as a comma-separared list after a ':' following the validator name. Example of a compact format specification with 2 validators, one of them ( len ) with validator parameters: spec = { 'field_name' : 'required|len:2,4' }","title":"Specification: Compact format"},{"location":"validators/#available-validators","text":"The complete list of available validators is available here .","title":"Available validators"},{"location":"validators/#optional-fields-and-aborting-on-first-fail","text":"","title":"Optional fields and aborting on first fail"},{"location":"validators/#chaining-validators","text":"","title":"Chaining validators"},{"location":"validators/#validator-class","text":"","title":"Validator Class"},{"location":"validators/#adding-custom-validators","text":"","title":"Adding custom Validators"},{"location":"validators/validator_list/","text":"Available validators General Validators Name Parameters Description required Value is required bail Special validator to skip running all validators on failure id Value must be a positive numeric greater than 0 uuid Value must be a valid UUID notempty Value must not be empty in list,of,values... Value must be in the specified list of values notin list,of,values... Value must not be in the specified list of values strin list,of,values... Value is a string and must be in the specified list of values strnotin list,of,values... Value is a string and must not be in the specified list of values bool Value must be a valid bool representation: 0, 1, y, t, true, n, f, false iso8601 Value must be a valid iso8601 date string String Validators Name Parameters Description alpha Value must contain only letters a-z and A-Z alphanum Value must contain only letters a-z and A-Z or digits 0-9 slug Value must be an alphanum string, but that can contain '-' and '_' len min,max Value char length must be between min and max minlen min Value char length must be at least min chars maxlen max Value char length must be upto max chars List Validators Name Parameters Description list Value must be a list of items listlen min[, max]] Item list must have at least min elements and optionally max elements Numeric Validators Name Parameters Description between min,max Value must be numeric between min and max; Floats are supported numeric Value must be a numeral (digits only) decimal Value must be a valid decimal numeral Network Validators Name Parameters Description ipv4 Value must be a valid IPv4 address ipv6 Value must be a valid IPv6 address ip Value must be a valid IPv4 or IPv6 address fqdn Value must be a valid fqdn (fully qualified domain name) email Value must be a valid email address mac Value must be a valid MAC address Hash Validators Name Parameters Description md5 Value must be a valid MD5 hash sha1 Value must be a valid SHA1 hash sha256 Value must be a valid SHA256 hash sha512 Value must be a valid SHA512 hash","title":"Available Validators"},{"location":"validators/validator_list/#available-validators","text":"","title":"Available validators"},{"location":"validators/validator_list/#general-validators","text":"Name Parameters Description required Value is required bail Special validator to skip running all validators on failure id Value must be a positive numeric greater than 0 uuid Value must be a valid UUID notempty Value must not be empty in list,of,values... Value must be in the specified list of values notin list,of,values... Value must not be in the specified list of values strin list,of,values... Value is a string and must be in the specified list of values strnotin list,of,values... Value is a string and must not be in the specified list of values bool Value must be a valid bool representation: 0, 1, y, t, true, n, f, false iso8601 Value must be a valid iso8601 date string","title":"General Validators"},{"location":"validators/validator_list/#string-validators","text":"Name Parameters Description alpha Value must contain only letters a-z and A-Z alphanum Value must contain only letters a-z and A-Z or digits 0-9 slug Value must be an alphanum string, but that can contain '-' and '_' len min,max Value char length must be between min and max minlen min Value char length must be at least min chars maxlen max Value char length must be upto max chars","title":"String Validators"},{"location":"validators/validator_list/#list-validators","text":"Name Parameters Description list Value must be a list of items listlen min[, max]] Item list must have at least min elements and optionally max elements","title":"List Validators"},{"location":"validators/validator_list/#numeric-validators","text":"Name Parameters Description between min,max Value must be numeric between min and max; Floats are supported numeric Value must be a numeral (digits only) decimal Value must be a valid decimal numeral","title":"Numeric Validators"},{"location":"validators/validator_list/#network-validators","text":"Name Parameters Description ipv4 Value must be a valid IPv4 address ipv6 Value must be a valid IPv6 address ip Value must be a valid IPv4 or IPv6 address fqdn Value must be a valid fqdn (fully qualified domain name) email Value must be a valid email address mac Value must be a valid MAC address","title":"Network Validators"},{"location":"validators/validator_list/#hash-validators","text":"Name Parameters Description md5 Value must be a valid MD5 hash sha1 Value must be a valid SHA1 hash sha256 Value must be a valid SHA256 hash sha512 Value must be a valid SHA512 hash","title":"Hash Validators"}]}