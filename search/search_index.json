{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Rick","text":"<p>Rick is a plumbing library for micro framework design. It provides base classes for miscellaneous purposes, ranging from dependency injection to validation. However, it does not include any HTTP/{A,W}SGI functionality, nor any database-related  functionality; you should instead using other existing projects for that functionality, such as Flask for MVC and RickDb for database operations.</p>"},{"location":"#components","title":"Components","text":"<ul> <li>Dependency Injection (DI) class;</li> <li>Container class;</li> <li>Generic resource map loader class;</li> <li>Registry class;</li> <li>Cache interface;</li> <li>REDIS cache client;</li> <li>AES256 crypto functions for cache mechanisms;</li> <li>Event manager;</li> <li>Request validator;</li> <li>Form management</li> <li>Validation classes;</li> <li>Filters</li> </ul>"},{"location":"filters/","title":"Filters","text":"<p>Filter classes are helper classes used to transform a specific source value (tipically a string) into a specific data type, such as a string into a datetime object. The lifecycle of filter class objects is usually managed via a Registry, but many contexts that accept a filter name will also accept a custom filter class.</p> <p>These classes don't perform any validation of the passed values; if the conversion operation fails, they will silently return None. </p>"},{"location":"filters/#using-filters","title":"Using filters","text":"<p>While Filters are often use within the scope of a Form, FieldRecord or RequestRecord, they can also be used in standalone: <pre><code>from datetime import datetime\nfrom rick.filter import registry as filter_registry\n# retrieve a filter to convert a string to a datetime object\nfilter = filter_registry.get('datetime')\n# use the filter to convert the string to an object\nresult = filter.transform('2022-05-31T15:11Z')\n# console output: True\nprint(isinstance(result, datetime))\n</code></pre></p>"},{"location":"filters/#creating-filters","title":"Creating Filters","text":"<p>Filter classes must extend the Filter base class, and implement the appropriate behaviour in the overridden transform() method:</p> <pre><code>from datetime import datetime\nfrom rick.filter import registry as filter_registry, Filter\nfrom typing import Any\nfrom dataclasses import dataclass\n# our new Dude type\n@dataclass\nclass Dude:\ngreeting: str\n# add our new filter to registry, with the name 'dude'\n@filter_registry.register_cls('dude')\nclass DudeFilter(Filter):\ndef transform(self, src: Any) -&gt; Dude:\n# all values are now dude objects!\nreturn Dude(greeting=\"Hey dude!\")\n# retrieve a filter to convert a string to a \"dude\"\nfilter = filter_registry.get('dude')\n# use the filter to convert the string to a dude\nresult = filter.transform('the quick brown fox jumps over the lazy dog')\n# console output: \"Hey Dude!\"\nprint(result.greeting)\n</code></pre>"},{"location":"forms/","title":"Working with Forms","text":"<p>rick.Form is a generic Form component to aid the maintenance of a form or request lifecycle.  It supports the declaration of fields, field groups (fieldsets) and perform validation on those fields, including custom validation. Due to its agnostic nature, it does not provide any form rendering mechanism.</p>"},{"location":"forms/#custom-validation","title":"Custom Validation","text":"<p>It is possible to perform additional custom validation on a given field to be executed automatically - just add a method with the name validate_(data, field: Field) to your class, where data will be the dict with the received values to validate, and field is the current field object for the specified field.  <p>Note: The custom validator methods are only executed if the initial validation of the form is valid (after all the specified field validators on the field definition are run and validated True); If the form isn't valid, these methods are not executed.</p> <p>Custom validation method example:</p> <pre><code>from rick.form import Form, Field\nclass ExampleForm(Form):\ndef init(self):\nself.field('text', 'name', 'Name', validators=\"required|minlen:4|maxlen:8\")\nreturn self\ndef validator_name(self, data, field: Field):\n# this validator is only run if standard form validation is successful\nif data['name'] == 'Dave':\nself.add_error('name', 'Dave is not here, man')\nreturn False\nreturn True\nfrm = ExampleForm().init()\n# trigger a failure on the field validators\n# the additional existing validator method for field 'name' won't be called \nvalid = frm.is_valid({'name': 'Teo'})\nprint(valid, frm.get_errors())\n# trigger a failure on the validation method\n# the field validators executed without errors\nvalid = frm.is_valid({'name': 'Dave'})\nprint(valid, frm.get_errors())\n# Console output:\n# False {'name': {'minlen': 'minimum allowed length is 4'}}\n# False {'name': {'*': 'Dave is not here, man'}}\n#\n</code></pre>"},{"location":"forms/errors/","title":"RequestRecord/Form error messages","text":"<p>RequestRecord and form error messages have the following structure:</p> <p><pre><code>{\n  field_name: {\n    validator_name: error_message,\n    validator_name: error_message\n  },\n  field-name: {...}\n}\n</code></pre> Where field_name is the field id, and validator_name either the name of the failing validator, or '*' for generic error messages for the field.</p> <p>Example result, with two failing validations on a single field: <pre><code> {\n\"age\": {\n\"between\": \"must be between 9 and 125\",\n\"numeric\": \"only digits allowed\"\n}\n}\n</code></pre></p>"},{"location":"forms/errors/#nested-records","title":"Nested Records","text":"<p>Nested record errors are signaled by using '_' as validator name. The nested record can either be a single record, or a list of records:</p> <p>Structure for single record: <pre><code>{\n  field_name: {\n    validator_name: error_message,\n    validator_name: error_message\n  },\n  field-name: {\n    validator_name: error_message,\n    \"_\": {\n        field_name: {\n            validator_name: error_message,\n            validator_name: error_message,\n        },\n        field_name: {\n            validator_name: error_message,\n            validator_name: error_message,\n        },\n    }\n  }\n}\n</code></pre></p> <p>Structure for a list of records (notice the sequence number to identify the failing record position): <pre><code>{\n  field_name: {\n    validator_name: error_message,\n    validator_name: error_message\n  },\n  field-name: {\n    validator_name: error_message,\n    \"_\": {\n        \"sequence number\": {\n            field_name: {\n                validator_name: error_message,\n                validator_name: error_message,\n            },\n            field_name: {\n                validator_name: error_message,\n                validator_name: error_message,\n            },\n        }\n    }\n  }\n}\n</code></pre></p>"},{"location":"forms/field.class/","title":"Class rick.form.Field","text":"<p>Base field class.</p>"},{"location":"forms/form.class/","title":"Class rick.form.Form","text":"<p>Base form class.</p>"},{"location":"forms/form.class/#property-formfields","title":"@property Form.fields","text":"<p>Form field dictionary, indexed by field id. Each entry is a Field object. </p>"},{"location":"forms/form.class/#forminittranslator-translator-none","title":"Form.init(translator: Translator = None)","text":"<p>Form Constructor. Initializes the form object, and optionally receives a Translator mixin to provide translation services to all the fields and fieldsets.</p>"},{"location":"forms/requests/","title":"Managing Requests","text":"<p>Rick provides several distinct classes to aid the management of request data: RequestRecord and Form. While these classes share a common syntax, their use cases are different. RequestRecord is designed to just handle structured request data; Form extends RequestRecord with additional control and grouping logic, useful for generating and processing HTML forms.</p>"},{"location":"forms/requests/#requestrecord","title":"RequestRecord","text":"<p>RequestRecord provides two ways for defining fields and field-related validation and filtering operations; A terse version, suitable for most usage scenarios, where the fields are specified directly in the class declaration (via fields  attribute), or in runtime by using an initializer method, often called init().</p> <p>Declaring fields directly using class attributes: <pre><code>from rick.form import RequestRecord, field\nclass UserRequest(RequestRecord):\nfields = {\n'id': field(validators=\"numeric\"),\n'name': field(validators=\"required|maxlen:128\"),\n'age': field(validators=\"required|numeric|between:18,120\")\n}\n</code></pre></p> <p>Declaring fields inside an initializer method: <pre><code>from rick.form import RequestRecord\nfrom rick.mixin import Translator\n# Custom class using runtime field definitions, and a custom field validator\nclass UserRequest(RequestRecord):\ndef init(self):\nself.field('id', validators=\"required|minlen:4|maxlen:8\") \\\n            .field('age', validators=\"required|numeric|between:9,125\") \\\n            .field('phone',validators=\"numeric|minlen:8|maxlen:16\")\nreturn self\n</code></pre></p>"},{"location":"forms/requests/#requestrecord-validation","title":"RequestRecord validation","text":"<p>There are two levels of validation: a first one, using the declared validators, and a second one using optional methods to perform additional validation.</p> <p>Validation of data is done by using RequestRecord's is_valid() method. This method receives a dictionary of field names and values, and returns either True or False, reflecting if all the values for the defined fields pass the predefined validators or not, as well as the optional validation methods.</p> <p>Note: internally, the validation is performed as a two-step operation - if any of the declared field validators fail validation, no magic validation methods are called. Magic validation methods will only be executed for any given field if all the predefined field validations pass.</p> <p>The rationale for this is to avoid having to perform basic validations within the method body, simplifying the implementation of additional validation logic. This way, when any magic method is called, it is guaranteed that the available data passed the field validations.</p>"},{"location":"forms/requests/#field-validators","title":"Field validators","text":"<p>field validators can be specified using any format compatible with rick.Validator usage, but commonly will use the string Laravel-style compact form:</p> <pre><code>from rick.form import RequestRecord, field\nclass AgeRequest(RequestRecord):\nfields = {\n# age field with several validators\n'age': field(validators=\"required|numeric|between:18,120\")\n}\n# create the request validation object to be used\nreq = AgeRequest()\n# some invalid data to fail validation\ndata = {\n'name': 'John Connor',\n'age': '1a'\n}\n# validate data, should fail\nif not req.is_valid(data):\n# will print: \n# {'age': {'numeric': 'only digits allowed', 'between': 'must be between 18 and 120'}}\nprint(req.get_errors())\n</code></pre> <p>Each failing validator will generate an error message; it is possible to override all error messages for a given field by just providing a custom error message:</p> <pre><code>from rick.form import RequestRecord, field\nclass AgeRequest(RequestRecord):\nfields = {\n# age field with several validators\n'age': field(validators=\"required|numeric|between:18,120\", error=\"invalid age\")\n}\n# create the request validation object to be used\nreq = AgeRequest()\n# some invalid data to fail validation\ndata = {\n'name': 'John Connor',\n'age': '1a'\n}\n# validate data, should fail\nif not req.is_valid(data):\n# will print: \n# {'age': {'*': 'invalid age'}}\nprint(req.get_errors())\n</code></pre>"},{"location":"forms/requests/#method-validators","title":"Method validators","text":"<p>As mentioned, RequestRecord allows for the optional declaration of magic validation methods that are called automatically during the internal second validation step. These methods can be used to perform additional validation logic, such as dependencies between fields or database lookups.</p> <p>The methods must be named validator_(data, t:Translator) and conform to the defined interface: <pre><code>from rick.form import RequestRecord, field\nfrom rick.mixin import Translator\n# Custom class using runtime field definitions, and a custom field validator\nclass MyFieldRecord(RequestRecord):\nfields = {\n'name': field(validators=\"required|minlen:4|maxlen:8\"),\n'age': field(validators=\"required|numeric|between:9,125\"),\n'phone': field(validators=\"numeric|minlen:8|maxlen:16\")\n}\n# custom validator method for field 'name'\n# this will only be executed if all field validators are successful\ndef validator_name(self, data, t:Translator):\n# 'data' is the field:value dictionary passed to is_valid(); it\n# contains all raw field values\nif data['name'] == 'dave':\n# add a custom error for field 'name'\nself.add_error('name', 'Dave is not here, man')\nreturn False\nreturn True\ndata = {\n'name': 'dave',\n'age': 12,\n'phone': '12312312'\n}\nfrm = MyFieldRecord()\nif not  frm.is_valid(data):\n# will print:\n# {'name': {'*': 'Dave is not here, man'}}\nprint(frm.get_errors())\n</code></pre>"},{"location":"forms/requests/#retrieving-validation-errors","title":"Retrieving validation errors","text":"<p>Validation errors are made available via get_errors(), using the documented format.</p>"},{"location":"forms/requests/#nested-requestrecord-structures","title":"Nested RequestRecord structures","text":"<p>RequestRecord classes can be nested to build complex request validation structures. This can be achieved using the record() helper function to describe dict-like records, or recordset() helper function to describe lists of dict-like records.</p> <p>Internally, records are also represented as fields, so filtered values can be accessed like any other regular field.</p> <p>Example: <pre><code>from rick.form import RequestRecord, field, record, recordset\nfrom rick.mixin import Translator\n# Request class describing a player structure\nclass Player(RequestRecord):\nfields = {\n'name': field(validators=\"required|minlen:4|maxlen:32\"),\n'age': field(validators=\"required|numeric|between:9,125\"),\n}\n# Request class for a team\nclass TeamRequest(RequestRecord):\nfields = {\n'team_name': field(validators=\"required|minlen:4|maxlen:64\"),\n# specify a field 'players' as a list of type Player, for validation purposes\n'players': recordset(Player)\n}\n# Request class for a team leader\nclass TeamLeaderRequest(RequestRecord):\nfields = {\n'team_name': field(validators=\"required|minlen:4|maxlen:64\"),\n# specify a field 'players' as a single record of type Player, for validation purposes\n'leader': record(Player)\n}\n# sample request data for TeamRequest    \nteam_data = {\n'team_name': 'super team',\n'players': [\n{\n'name': 'susan',\n'age': 32\n},\n{\n'name': 'mary',\n'age': 21\n},\n]\n}\n# validate data for TeamRequest\nrequest = TeamRequest()\nif request.is_valid(team_data):\nprint('Team data is valid!')\n# sample request data for TeamLeaderRequest    \nteam_leader_data = {\n'team_name': 'super team',\n'leader': {\n'name': 'susan',\n'age': 32\n}\n}\n# validate data for TeamLeaderRequest\nrequest = TeamLeaderRequest()\nif request.is_valid(team_leader_data):\nprint('Team leader data is valid!')\n</code></pre></p>"},{"location":"mixins/translator.class/","title":"Mixin rick.mixin.Translator","text":"<p>Mixin to provide an interface for string translation</p>"},{"location":"mixins/translator.class/#translatorttext-str-str","title":"Translator.t(text: str) -&gt; str:","text":"<p>Method signature to perform a string translation. By default, the mixin implementation returns the passed text value.</p>"},{"location":"validators/","title":"Validators","text":"<p>Rick validators is a registry-based reusable approach to validation operations. It implements a programmatic approach of validating a dictionary of fields and values against a predefined validation specification. This specification can either  be in dictionary format (suitable when specs are read from external sources, such as JSON), or in compact format, a string-based format based on PHP Laravel's validator specification, suitable for inline or programmatic usage.</p>"},{"location":"validators/#tldr-example","title":"TL;DR; Example","text":"<pre><code>from rick.validator import Validator\n# a compact spec example\nspec_compact = {\n'field1': 'required|maxlen:3',  # field is required, maximum length is 3\n'field2': 'minlen:4', # field is optional, minimum length is 4\n'field3': 'required|numeric|len:2,4' # field is required, must be digits, with a length between 2 and 4\n}\n# a dict spec example\nspec_dict = {\n'field1': {\n'required': None,\n'maxlen': 3,\n},\n'field2': {\n'minlen': 4,\n},\n'field3': {\n'required': None,\n'numeric': None,\n'len': [2, 4],\n}\n}\n# field data dict to perform validation on\nfields_values = {\n'field1': 'abc',\n'field2': 'def',\n'field3': 12345\n}\n# validate compact notation\nv = Validator(spec_compact)\n# perform validation, should return False with errors in field2 and field3\nvalid = v.is_valid(fields_values)\n#\n# console output:\n# False {'field2': {'minlen': 'minimum allowed length is 4'}, 'field3': {'len': 'length must be between [2, 4]'}}\nprint(valid, v.get_errors())\n# validate with dict notation\nv = Validator(spec_dict)\n# perform validation, should return False with errors in field2 and field3\nvalid = v.is_valid(fields_values)\n#\n# console output:\n# False {'field2': {'minlen': 'minimum allowed length is 4'}, 'field3': {'len': 'length must be between [2, 4]'}}\nprint(valid, v.get_errors())\n# retrieve errors for specific fields\n#\n# console output: {'minlen': 'minimum allowed length is 4'}\nprint(v.get_errors('field2'))\n#\n# console output: {'len': 'length must be between [2, 4]'}\nprint(v.get_errors('field3'))\n# Simulate optional field - remove field2 from value dictionary\n# the validation result should fail, but without any error for field2, because its absent\nfields_values.pop('field2')\nvalid = v.is_valid(fields_values)\n#\n# console output:\n# False {'field3': {'len': 'length must be between [2, 4]'}}\nprint(valid, v.get_errors())\n</code></pre>"},{"location":"validators/#specification-dict-format","title":"Specification: Dict format","text":"<p>The dict format spectification is a 2-level dictionary, where the first level keys are field names, and the second level keys are validator names and optional parameters.</p> <p>Example of a dict format specification with 2 validators, one of them (len) with validator parameters: <pre><code>spec = {\n'field_name': {\n'required': None,\n'len':[2,4]\n}\n}\n</code></pre></p>"},{"location":"validators/#specification-compact-format","title":"Specification: Compact format","text":"<p>The compact format specification is a string with one or several validator names concatenated with '|'. Some validators require one or more parameters; these are specified as a comma-separared list after a ':' following the validator name.</p> <p>Example of a compact format specification with 2 validators, one of them (len) with validator parameters: <pre><code>spec = {\n'field_name': 'required|len:2,4'\n}\n</code></pre></p>"},{"location":"validators/#available-validators","title":"Available validators","text":"<p>The complete list of available validators is available here.</p>"},{"location":"validators/#optional-fields-and-aborting-on-first-fail","title":"Optional fields and aborting on first fail","text":""},{"location":"validators/#chaining-validators","title":"Chaining validators","text":""},{"location":"validators/#validator-class","title":"Validator Class","text":""},{"location":"validators/#adding-custom-validators","title":"Adding custom Validators","text":""},{"location":"validators/validator_list/","title":"Available validators","text":""},{"location":"validators/validator_list/#general-validators","title":"General Validators","text":"Name Parameters Description required Value is required bail Special validator to skip running all validators on failure id Value must be a positive numeric greater than 0 uuid Value must be a valid UUID notempty Value must not be empty in list,of,values... Value must be in the specified list of values notin list,of,values... Value must not be in the specified list of values strin list,of,values... Value is a string and must be in the specified list of values strnotin list,of,values... Value is a string and must not be in the specified list of values bool Value must be a valid bool representation: 0, 1, y, t, true, n, f, false iso8601 Value must be a valid iso8601 date string"},{"location":"validators/validator_list/#string-validators","title":"String Validators","text":"Name Parameters Description alpha Value must contain only letters a-z and A-Z alphanum Value must contain only letters a-z and A-Z or digits 0-9 slug Value must be an alphanum string, but that can contain '-' and '_' len min,max Value char length must be between min and max minlen min Value char length must be at least min chars maxlen max Value char length must be upto max chars"},{"location":"validators/validator_list/#list-validators","title":"List Validators","text":"Name Parameters Description list Value must be a list of items listlen min[, max]] Item list must have at least min elements and optionally max elements"},{"location":"validators/validator_list/#numeric-validators","title":"Numeric Validators","text":"Name Parameters Description between min,max Value must be numeric between min and max; Floats are supported numeric Value must be a numeral (digits only) decimal Value must be a valid decimal numeral"},{"location":"validators/validator_list/#network-validators","title":"Network Validators","text":"Name Parameters Description ipv4 Value must be a valid IPv4 address ipv6 Value must be a valid IPv6 address ip Value must be a valid IPv4 or IPv6 address fqdn Value must be a valid fqdn (fully qualified domain name) email Value must be a valid email address mac Value must be a valid MAC address"},{"location":"validators/validator_list/#hash-validators","title":"Hash Validators","text":"Name Parameters Description md5 Value must be a valid MD5 hash sha1 Value must be a valid SHA1 hash sha256 Value must be a valid SHA256 hash sha512 Value must be a valid SHA512 hash"}]}